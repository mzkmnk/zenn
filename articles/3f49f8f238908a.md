---
title: "Typical DP Contestをpythonで解いてみた"
emoji: "🐥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [python,atcoder,アルゴリズム,DP]
published: true
---

# A-コンテスト
自力AC(2023/10/30)

問題文 : https://atcoder.jp/contests/tdpc/tasks/tdpc_contest

コード : https://atcoder.jp/contests/tdpc/submissions/47095237

この問題はnまで解いた時にできる点数iをTrueとして遷移を行いました。
ただ今回はn行持つ必要はなくロールバックで遷移をすれば一次元配列を持つだけで大丈夫となります。
なぜロールバックで行うのかというとこの場合はp[i]をいくつでもつかえるのではなく一回しか使えないためそのまま前から遷移を行うと複数回使ってしまうことになります。

問題のテストケース1でp[0]=2として前から遷移をすると(配列の個数は10とします。)
$$[1,0,0,0,0,0,0,0,0,0,0]$$
から
$$[1,0,1,0,1,0,1,0,1,0,1]$$
となってしまい、2を複数個使うことになってしまいます。なのでロールバックをすることで1回しか使わないということになります。

初期値は
$$dp[0]=1$$
遷移は
$$dp[i]=dp[i-p[j]]\;|\;dp[i](i-p[j]>=0)$$
となります。

# D-サイコロ
解説AC(2023/10/30)

問題文 : https://atcoder.jp/contests/tdpc/tasks/tdpc_dice
コード : https://atcoder.jp/contests/tdpc/submissions/47093462

この問題は手も足もでなかったです、、この問題はサイコロは1から6までの数字しかないので、Dが1から6以外の倍数を持っていると答えは0になります。この問題では、n回サイコロを振った時に出るjの確率を保存することで解くことができます。つまりDの積になるということはDで割ることで0になる確率を足していけば確率が求められます。
よってdpはn回サイコロを振った時に出るjの確率として求めることができます。自分の場合はdefaultdict(int)を用いて実装しました。

初期値は
$$dp[1]=1$$
遷移は
$$dp\_copy[(j*k)\%D]+=dp[j]/6.0(1<=k<=6)$$
$$dp=dp\_copy.copy()$$
$$dp\_copy.clear()$$
となります